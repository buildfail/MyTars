/**
 * Tencent is pleased to support the open source community by making Tars available.
 *
 * Copyright (C) 2016THL A29 Limited, a Tencent company. All rights reserved.
 *
 * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except 
 * in compliance with the License. You may obtain a copy of the License at
 *
 * https://opensource.org/licenses/BSD-3-Clause
 *
 * Unless required by applicable law or agreed to in writing, software distributed 
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR 
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the 
 * specific language governing permissions and limitations under the License.
 */

// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __TYPEDEMO_H_
#define __TYPEDEMO_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace TarsTest
{

    /* callback of async proxy for client */
    class TypeDemoPrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~TypeDemoPrxCallback(){}
        virtual void callback_echoBool(tars::Int32 ret, tars::Bool bEcho)
        { throw std::runtime_error("callback_echoBool() override incorrect."); }
        virtual void callback_echoBool_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_echoBool_exception() override incorrect."); }

        virtual void callback_echoByte(tars::Int32 ret, tars::Char bEcho)
        { throw std::runtime_error("callback_echoByte() override incorrect."); }
        virtual void callback_echoByte_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_echoByte_exception() override incorrect."); }

        virtual void callback_echoInt(tars::Int32 ret, tars::Int32 iEcho)
        { throw std::runtime_error("callback_echoInt() override incorrect."); }
        virtual void callback_echoInt_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_echoInt_exception() override incorrect."); }

        virtual void callback_echoLong(tars::Int32 ret, tars::Int64 lEcho)
        { throw std::runtime_error("callback_echoLong() override incorrect."); }
        virtual void callback_echoLong_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_echoLong_exception() override incorrect."); }

        virtual void callback_echoMap(tars::Int32 ret,  const map<tars::Int32, std::string>& mEcho)
        { throw std::runtime_error("callback_echoMap() override incorrect."); }
        virtual void callback_echoMap_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_echoMap_exception() override incorrect."); }

        virtual void callback_echoMultiType(tars::Int32 ret,  const vector<map<tars::Int32, std::string> >& mtEcho)
        { throw std::runtime_error("callback_echoMultiType() override incorrect."); }
        virtual void callback_echoMultiType_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_echoMultiType_exception() override incorrect."); }

        virtual void callback_echoShort(tars::Int32 ret, tars::Short sEcho)
        { throw std::runtime_error("callback_echoShort() override incorrect."); }
        virtual void callback_echoShort_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_echoShort_exception() override incorrect."); }

        virtual void callback_echoString(tars::Int32 ret,  const std::string& strEcho)
        { throw std::runtime_error("callback_echoString() override incorrect."); }
        virtual void callback_echoString_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_echoString_exception() override incorrect."); }

        virtual void callback_echoVector(tars::Int32 ret,  const vector<tars::Int32>& vEcho)
        { throw std::runtime_error("callback_echoVector() override incorrect."); }
        virtual void callback_echoVector_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_echoVector_exception() override incorrect."); }

        virtual void callback_test(tars::Int32 ret)
        { throw std::runtime_error("callback_test() override incorrect."); }
        virtual void callback_test_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_test_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __TypeDemo_all[]=
            {
                "echoBool",
                "echoByte",
                "echoInt",
                "echoLong",
                "echoMap",
                "echoMultiType",
                "echoShort",
                "echoString",
                "echoVector",
                "test"
            };
            pair<string*, string*> r = equal_range(__TypeDemo_all, __TypeDemo_all+10, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __TypeDemo_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoBool_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Bool bEcho = false;
                    _is.read(bEcho, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_echoBool(_ret, bEcho);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoByte_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Char bEcho;
                    _is.read(bEcho, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_echoByte(_ret, bEcho);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoInt_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Int32 iEcho;
                    _is.read(iEcho, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_echoInt(_ret, iEcho);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoLong_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Int64 lEcho;
                    _is.read(lEcho, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_echoLong(_ret, lEcho);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoMap_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    map<tars::Int32, std::string> mEcho;
                    _is.read(mEcho, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_echoMap(_ret, mEcho);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoMultiType_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<map<tars::Int32, std::string> > mtEcho;
                    _is.read(mtEcho, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_echoMultiType(_ret, mtEcho);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoShort_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::Short sEcho;
                    _is.read(sEcho, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_echoShort(_ret, sEcho);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoString_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string strEcho;
                    _is.read(strEcho, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_echoString(_ret, strEcho);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoVector_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::Int32> vEcho;
                    _is.read(vEcho, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_echoVector(_ret, vEcho);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_test_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_test(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<TypeDemoPrxCallback> TypeDemoPrxCallbackPtr;

    /* callback of promise async proxy for client */
    class TypeDemoPrxCallbackPromise: public tars::ServantProxyCallback
    {
    public:
        virtual ~TypeDemoPrxCallbackPromise(){}
    public:
        struct PromiseechoBool: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Bool bEcho;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TypeDemoPrxCallbackPromise::PromiseechoBool > PromiseechoBoolPtr;

        TypeDemoPrxCallbackPromise(const promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoBoolPtr > &promise)
        : _promise_echoBool(promise)
        {}
        
        virtual void callback_echoBool(const TypeDemoPrxCallbackPromise::PromiseechoBoolPtr &ptr)
        {
            _promise_echoBool.setValue(ptr);
        }
        virtual void callback_echoBool_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:echoBool_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_echoBool.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoBoolPtr > _promise_echoBool;

    public:
        struct PromiseechoByte: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Char bEcho;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TypeDemoPrxCallbackPromise::PromiseechoByte > PromiseechoBytePtr;

        TypeDemoPrxCallbackPromise(const promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoBytePtr > &promise)
        : _promise_echoByte(promise)
        {}
        
        virtual void callback_echoByte(const TypeDemoPrxCallbackPromise::PromiseechoBytePtr &ptr)
        {
            _promise_echoByte.setValue(ptr);
        }
        virtual void callback_echoByte_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:echoByte_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_echoByte.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoBytePtr > _promise_echoByte;

    public:
        struct PromiseechoInt: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Int32 iEcho;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TypeDemoPrxCallbackPromise::PromiseechoInt > PromiseechoIntPtr;

        TypeDemoPrxCallbackPromise(const promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoIntPtr > &promise)
        : _promise_echoInt(promise)
        {}
        
        virtual void callback_echoInt(const TypeDemoPrxCallbackPromise::PromiseechoIntPtr &ptr)
        {
            _promise_echoInt.setValue(ptr);
        }
        virtual void callback_echoInt_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:echoInt_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_echoInt.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoIntPtr > _promise_echoInt;

    public:
        struct PromiseechoLong: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Int64 lEcho;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TypeDemoPrxCallbackPromise::PromiseechoLong > PromiseechoLongPtr;

        TypeDemoPrxCallbackPromise(const promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoLongPtr > &promise)
        : _promise_echoLong(promise)
        {}
        
        virtual void callback_echoLong(const TypeDemoPrxCallbackPromise::PromiseechoLongPtr &ptr)
        {
            _promise_echoLong.setValue(ptr);
        }
        virtual void callback_echoLong_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:echoLong_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_echoLong.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoLongPtr > _promise_echoLong;

    public:
        struct PromiseechoMap: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<tars::Int32, std::string> mEcho;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TypeDemoPrxCallbackPromise::PromiseechoMap > PromiseechoMapPtr;

        TypeDemoPrxCallbackPromise(const promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoMapPtr > &promise)
        : _promise_echoMap(promise)
        {}
        
        virtual void callback_echoMap(const TypeDemoPrxCallbackPromise::PromiseechoMapPtr &ptr)
        {
            _promise_echoMap.setValue(ptr);
        }
        virtual void callback_echoMap_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:echoMap_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_echoMap.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoMapPtr > _promise_echoMap;

    public:
        struct PromiseechoMultiType: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<map<tars::Int32, std::string> > mtEcho;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TypeDemoPrxCallbackPromise::PromiseechoMultiType > PromiseechoMultiTypePtr;

        TypeDemoPrxCallbackPromise(const promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoMultiTypePtr > &promise)
        : _promise_echoMultiType(promise)
        {}
        
        virtual void callback_echoMultiType(const TypeDemoPrxCallbackPromise::PromiseechoMultiTypePtr &ptr)
        {
            _promise_echoMultiType.setValue(ptr);
        }
        virtual void callback_echoMultiType_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:echoMultiType_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_echoMultiType.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoMultiTypePtr > _promise_echoMultiType;

    public:
        struct PromiseechoShort: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::Short sEcho;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TypeDemoPrxCallbackPromise::PromiseechoShort > PromiseechoShortPtr;

        TypeDemoPrxCallbackPromise(const promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoShortPtr > &promise)
        : _promise_echoShort(promise)
        {}
        
        virtual void callback_echoShort(const TypeDemoPrxCallbackPromise::PromiseechoShortPtr &ptr)
        {
            _promise_echoShort.setValue(ptr);
        }
        virtual void callback_echoShort_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:echoShort_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_echoShort.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoShortPtr > _promise_echoShort;

    public:
        struct PromiseechoString: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string strEcho;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TypeDemoPrxCallbackPromise::PromiseechoString > PromiseechoStringPtr;

        TypeDemoPrxCallbackPromise(const promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoStringPtr > &promise)
        : _promise_echoString(promise)
        {}
        
        virtual void callback_echoString(const TypeDemoPrxCallbackPromise::PromiseechoStringPtr &ptr)
        {
            _promise_echoString.setValue(ptr);
        }
        virtual void callback_echoString_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:echoString_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_echoString.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoStringPtr > _promise_echoString;

    public:
        struct PromiseechoVector: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<tars::Int32> vEcho;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TypeDemoPrxCallbackPromise::PromiseechoVector > PromiseechoVectorPtr;

        TypeDemoPrxCallbackPromise(const promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoVectorPtr > &promise)
        : _promise_echoVector(promise)
        {}
        
        virtual void callback_echoVector(const TypeDemoPrxCallbackPromise::PromiseechoVectorPtr &ptr)
        {
            _promise_echoVector.setValue(ptr);
        }
        virtual void callback_echoVector_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:echoVector_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_echoVector.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoVectorPtr > _promise_echoVector;

    public:
        struct Promisetest: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< TypeDemoPrxCallbackPromise::Promisetest > PromisetestPtr;

        TypeDemoPrxCallbackPromise(const promise::Promise< TypeDemoPrxCallbackPromise::PromisetestPtr > &promise)
        : _promise_test(promise)
        {}
        
        virtual void callback_test(const TypeDemoPrxCallbackPromise::PromisetestPtr &ptr)
        {
            _promise_test.setValue(ptr);
        }
        virtual void callback_test_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:test_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_test.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< TypeDemoPrxCallbackPromise::PromisetestPtr > _promise_test;

    public:
        virtual int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __TypeDemo_all[]=
            {
                "echoBool",
                "echoByte",
                "echoInt",
                "echoLong",
                "echoMap",
                "echoMultiType",
                "echoShort",
                "echoString",
                "echoVector",
                "test"
            };

            pair<string*, string*> r = equal_range(__TypeDemo_all, __TypeDemo_all+10, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __TypeDemo_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoBool_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TypeDemoPrxCallbackPromise::PromiseechoBoolPtr ptr = new TypeDemoPrxCallbackPromise::PromiseechoBool();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        ptr->bEcho = false;
                        _is.read(ptr->bEcho, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_echoBool_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoBool_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_echoBool(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoByte_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TypeDemoPrxCallbackPromise::PromiseechoBytePtr ptr = new TypeDemoPrxCallbackPromise::PromiseechoByte();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->bEcho, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_echoByte_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoByte_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_echoByte(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoInt_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TypeDemoPrxCallbackPromise::PromiseechoIntPtr ptr = new TypeDemoPrxCallbackPromise::PromiseechoInt();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->iEcho, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_echoInt_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoInt_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_echoInt(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoLong_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TypeDemoPrxCallbackPromise::PromiseechoLongPtr ptr = new TypeDemoPrxCallbackPromise::PromiseechoLong();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->lEcho, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_echoLong_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoLong_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_echoLong(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoMap_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TypeDemoPrxCallbackPromise::PromiseechoMapPtr ptr = new TypeDemoPrxCallbackPromise::PromiseechoMap();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->mEcho, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_echoMap_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoMap_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_echoMap(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoMultiType_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TypeDemoPrxCallbackPromise::PromiseechoMultiTypePtr ptr = new TypeDemoPrxCallbackPromise::PromiseechoMultiType();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->mtEcho, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_echoMultiType_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoMultiType_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_echoMultiType(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoShort_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TypeDemoPrxCallbackPromise::PromiseechoShortPtr ptr = new TypeDemoPrxCallbackPromise::PromiseechoShort();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->sEcho, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_echoShort_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoShort_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_echoShort(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoString_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TypeDemoPrxCallbackPromise::PromiseechoStringPtr ptr = new TypeDemoPrxCallbackPromise::PromiseechoString();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->strEcho, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_echoString_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoString_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_echoString(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoVector_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TypeDemoPrxCallbackPromise::PromiseechoVectorPtr ptr = new TypeDemoPrxCallbackPromise::PromiseechoVector();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->vEcho, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_echoVector_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoVector_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_echoVector(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_test_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    TypeDemoPrxCallbackPromise::PromisetestPtr ptr = new TypeDemoPrxCallbackPromise::Promisetest();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_test_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_test_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_test(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<TypeDemoPrxCallbackPromise> TypeDemoPrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class TypeDemoCoroPrxCallback: public TypeDemoPrxCallback
    {
    public:
        virtual ~TypeDemoCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __TypeDemo_all[]=
            {
                "echoBool",
                "echoByte",
                "echoInt",
                "echoLong",
                "echoMap",
                "echoMultiType",
                "echoShort",
                "echoString",
                "echoVector",
                "test"
            };

            pair<string*, string*> r = equal_range(__TypeDemo_all, __TypeDemo_all+10, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __TypeDemo_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoBool_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Bool bEcho = false;
                        _is.read(bEcho, 2, true);
                        setResponseContext(msg->response.context);

                        callback_echoBool(_ret, bEcho);

                    }
                    catch(std::exception &ex)
                    {
                        callback_echoBool_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoBool_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoByte_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Char bEcho;
                        _is.read(bEcho, 2, true);
                        setResponseContext(msg->response.context);

                        callback_echoByte(_ret, bEcho);

                    }
                    catch(std::exception &ex)
                    {
                        callback_echoByte_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoByte_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoInt_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Int32 iEcho;
                        _is.read(iEcho, 2, true);
                        setResponseContext(msg->response.context);

                        callback_echoInt(_ret, iEcho);

                    }
                    catch(std::exception &ex)
                    {
                        callback_echoInt_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoInt_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoLong_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Int64 lEcho;
                        _is.read(lEcho, 2, true);
                        setResponseContext(msg->response.context);

                        callback_echoLong(_ret, lEcho);

                    }
                    catch(std::exception &ex)
                    {
                        callback_echoLong_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoLong_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoMap_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        map<tars::Int32, std::string> mEcho;
                        _is.read(mEcho, 2, true);
                        setResponseContext(msg->response.context);

                        callback_echoMap(_ret, mEcho);

                    }
                    catch(std::exception &ex)
                    {
                        callback_echoMap_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoMap_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoMultiType_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<map<tars::Int32, std::string> > mtEcho;
                        _is.read(mtEcho, 2, true);
                        setResponseContext(msg->response.context);

                        callback_echoMultiType(_ret, mtEcho);

                    }
                    catch(std::exception &ex)
                    {
                        callback_echoMultiType_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoMultiType_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoShort_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::Short sEcho;
                        _is.read(sEcho, 2, true);
                        setResponseContext(msg->response.context);

                        callback_echoShort(_ret, sEcho);

                    }
                    catch(std::exception &ex)
                    {
                        callback_echoShort_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoShort_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoString_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string strEcho;
                        _is.read(strEcho, 2, true);
                        setResponseContext(msg->response.context);

                        callback_echoString(_ret, strEcho);

                    }
                    catch(std::exception &ex)
                    {
                        callback_echoString_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoString_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_echoVector_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::Int32> vEcho;
                        _is.read(vEcho, 2, true);
                        setResponseContext(msg->response.context);

                        callback_echoVector(_ret, vEcho);

                    }
                    catch(std::exception &ex)
                    {
                        callback_echoVector_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_echoVector_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_test_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response.context);

                        callback_test(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_test_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_test_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<TypeDemoCoroPrxCallback> TypeDemoCoroPrxCallbackPtr;

    /* proxy for client */
    class TypeDemoProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Int32 echoBool(tars::Bool bInput,tars::Bool &bEcho,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(bInput, 1);
            _os.write(bEcho, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"echoBool", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(bEcho, 2, true);
            return _ret;
        }

        void async_echoBool(TypeDemoPrxCallbackPtr callback,tars::Bool bInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(bInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoBool", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TypeDemoPrxCallbackPromise::PromiseechoBoolPtr > promise_async_echoBool(tars::Bool bInput,const map<string, string>& context)
        {
            promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoBoolPtr > promise;
            TypeDemoPrxCallbackPromisePtr callback = new TypeDemoPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(bInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoBool", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_echoBool(TypeDemoCoroPrxCallbackPtr callback,tars::Bool bInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(bInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoBool", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 echoByte(tars::Char bInput,tars::Char &bEcho,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(bInput, 1);
            _os.write(bEcho, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"echoByte", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(bEcho, 2, true);
            return _ret;
        }

        void async_echoByte(TypeDemoPrxCallbackPtr callback,tars::Char bInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(bInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoByte", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TypeDemoPrxCallbackPromise::PromiseechoBytePtr > promise_async_echoByte(tars::Char bInput,const map<string, string>& context)
        {
            promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoBytePtr > promise;
            TypeDemoPrxCallbackPromisePtr callback = new TypeDemoPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(bInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoByte", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_echoByte(TypeDemoCoroPrxCallbackPtr callback,tars::Char bInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(bInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoByte", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 echoInt(tars::Int32 iInput,tars::Int32 &iEcho,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(iInput, 1);
            _os.write(iEcho, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"echoInt", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(iEcho, 2, true);
            return _ret;
        }

        void async_echoInt(TypeDemoPrxCallbackPtr callback,tars::Int32 iInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(iInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoInt", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TypeDemoPrxCallbackPromise::PromiseechoIntPtr > promise_async_echoInt(tars::Int32 iInput,const map<string, string>& context)
        {
            promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoIntPtr > promise;
            TypeDemoPrxCallbackPromisePtr callback = new TypeDemoPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(iInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoInt", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_echoInt(TypeDemoCoroPrxCallbackPtr callback,tars::Int32 iInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(iInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoInt", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 echoLong(tars::Int64 lInput,tars::Int64 &lEcho,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(lInput, 1);
            _os.write(lEcho, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"echoLong", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(lEcho, 2, true);
            return _ret;
        }

        void async_echoLong(TypeDemoPrxCallbackPtr callback,tars::Int64 lInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(lInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoLong", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TypeDemoPrxCallbackPromise::PromiseechoLongPtr > promise_async_echoLong(tars::Int64 lInput,const map<string, string>& context)
        {
            promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoLongPtr > promise;
            TypeDemoPrxCallbackPromisePtr callback = new TypeDemoPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(lInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoLong", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_echoLong(TypeDemoCoroPrxCallbackPtr callback,tars::Int64 lInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(lInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoLong", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 echoMap(const map<tars::Int32, std::string> & mInput,map<tars::Int32, std::string> &mEcho,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(mInput, 1);
            _os.write(mEcho, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"echoMap", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(mEcho, 2, true);
            return _ret;
        }

        void async_echoMap(TypeDemoPrxCallbackPtr callback,const map<tars::Int32, std::string> &mInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(mInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoMap", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TypeDemoPrxCallbackPromise::PromiseechoMapPtr > promise_async_echoMap(const map<tars::Int32, std::string> &mInput,const map<string, string>& context)
        {
            promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoMapPtr > promise;
            TypeDemoPrxCallbackPromisePtr callback = new TypeDemoPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(mInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoMap", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_echoMap(TypeDemoCoroPrxCallbackPtr callback,const map<tars::Int32, std::string> &mInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(mInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoMap", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 echoMultiType(const vector<map<tars::Int32, std::string> > & mtInput,vector<map<tars::Int32, std::string> > &mtEcho,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(mtInput, 1);
            _os.write(mtEcho, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"echoMultiType", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(mtEcho, 2, true);
            return _ret;
        }

        void async_echoMultiType(TypeDemoPrxCallbackPtr callback,const vector<map<tars::Int32, std::string> > &mtInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(mtInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoMultiType", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TypeDemoPrxCallbackPromise::PromiseechoMultiTypePtr > promise_async_echoMultiType(const vector<map<tars::Int32, std::string> > &mtInput,const map<string, string>& context)
        {
            promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoMultiTypePtr > promise;
            TypeDemoPrxCallbackPromisePtr callback = new TypeDemoPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(mtInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoMultiType", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_echoMultiType(TypeDemoCoroPrxCallbackPtr callback,const vector<map<tars::Int32, std::string> > &mtInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(mtInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoMultiType", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 echoShort(tars::Short sInput,tars::Short &sEcho,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(sInput, 1);
            _os.write(sEcho, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"echoShort", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(sEcho, 2, true);
            return _ret;
        }

        void async_echoShort(TypeDemoPrxCallbackPtr callback,tars::Short sInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(sInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoShort", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TypeDemoPrxCallbackPromise::PromiseechoShortPtr > promise_async_echoShort(tars::Short sInput,const map<string, string>& context)
        {
            promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoShortPtr > promise;
            TypeDemoPrxCallbackPromisePtr callback = new TypeDemoPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(sInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoShort", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_echoShort(TypeDemoCoroPrxCallbackPtr callback,tars::Short sInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(sInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoShort", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 echoString(const std::string & strInput,std::string &strEcho,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(strInput, 1);
            _os.write(strEcho, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"echoString", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(strEcho, 2, true);
            return _ret;
        }

        void async_echoString(TypeDemoPrxCallbackPtr callback,const std::string &strInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(strInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoString", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TypeDemoPrxCallbackPromise::PromiseechoStringPtr > promise_async_echoString(const std::string &strInput,const map<string, string>& context)
        {
            promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoStringPtr > promise;
            TypeDemoPrxCallbackPromisePtr callback = new TypeDemoPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(strInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoString", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_echoString(TypeDemoCoroPrxCallbackPtr callback,const std::string &strInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(strInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoString", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 echoVector(const vector<tars::Int32> & vInput,vector<tars::Int32> &vEcho,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(vInput, 1);
            _os.write(vEcho, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"echoVector", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(vEcho, 2, true);
            return _ret;
        }

        void async_echoVector(TypeDemoPrxCallbackPtr callback,const vector<tars::Int32> &vInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(vInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoVector", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TypeDemoPrxCallbackPromise::PromiseechoVectorPtr > promise_async_echoVector(const vector<tars::Int32> &vInput,const map<string, string>& context)
        {
            promise::Promise< TypeDemoPrxCallbackPromise::PromiseechoVectorPtr > promise;
            TypeDemoPrxCallbackPromisePtr callback = new TypeDemoPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(vInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoVector", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_echoVector(TypeDemoCoroPrxCallbackPtr callback,const vector<tars::Int32> &vInput,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(vInput, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"echoVector", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 test(const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"test", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_test(TypeDemoPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"test", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< TypeDemoPrxCallbackPromise::PromisetestPtr > promise_async_test(const map<string, string>& context)
        {
            promise::Promise< TypeDemoPrxCallbackPromise::PromisetestPtr > promise;
            TypeDemoPrxCallbackPromisePtr callback = new TypeDemoPrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"test", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_test(TypeDemoCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"test", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        TypeDemoProxy* tars_hash(int64_t key)
        {
            return (TypeDemoProxy*)ServantProxy::tars_hash(key);
        }

        TypeDemoProxy* tars_consistent_hash(int64_t key)
        {
            return (TypeDemoProxy*)ServantProxy::tars_consistent_hash(key);
        }

        TypeDemoProxy* tars_set_timeout(int msecond)
        {
            return (TypeDemoProxy*)ServantProxy::tars_set_timeout(msecond);
        }

    };
    typedef tars::TC_AutoPtr<TypeDemoProxy> TypeDemoPrx;

    /* servant for server */
    class TypeDemo : public tars::Servant
    {
    public:
        virtual ~TypeDemo(){}
        virtual tars::Int32 echoBool(tars::Bool bInput,tars::Bool &bEcho,tars::TarsCurrentPtr current) = 0;
        static void async_response_echoBool(tars::TarsCurrentPtr current, tars::Int32 _ret, tars::Bool bEcho)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("bEcho", bEcho);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(bEcho, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 echoByte(tars::Char bInput,tars::Char &bEcho,tars::TarsCurrentPtr current) = 0;
        static void async_response_echoByte(tars::TarsCurrentPtr current, tars::Int32 _ret, tars::Char bEcho)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("bEcho", bEcho);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(bEcho, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 echoInt(tars::Int32 iInput,tars::Int32 &iEcho,tars::TarsCurrentPtr current) = 0;
        static void async_response_echoInt(tars::TarsCurrentPtr current, tars::Int32 _ret, tars::Int32 iEcho)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("iEcho", iEcho);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(iEcho, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 echoLong(tars::Int64 lInput,tars::Int64 &lEcho,tars::TarsCurrentPtr current) = 0;
        static void async_response_echoLong(tars::TarsCurrentPtr current, tars::Int32 _ret, tars::Int64 lEcho)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("lEcho", lEcho);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(lEcho, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 echoMap(const map<tars::Int32, std::string> & mInput,map<tars::Int32, std::string> &mEcho,tars::TarsCurrentPtr current) = 0;
        static void async_response_echoMap(tars::TarsCurrentPtr current, tars::Int32 _ret, const map<tars::Int32, std::string> &mEcho)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("mEcho", mEcho);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(mEcho, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 echoMultiType(const vector<map<tars::Int32, std::string> > & mtInput,vector<map<tars::Int32, std::string> > &mtEcho,tars::TarsCurrentPtr current) = 0;
        static void async_response_echoMultiType(tars::TarsCurrentPtr current, tars::Int32 _ret, const vector<map<tars::Int32, std::string> > &mtEcho)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("mtEcho", mtEcho);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(mtEcho, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 echoShort(tars::Short sInput,tars::Short &sEcho,tars::TarsCurrentPtr current) = 0;
        static void async_response_echoShort(tars::TarsCurrentPtr current, tars::Int32 _ret, tars::Short sEcho)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("sEcho", sEcho);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(sEcho, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 echoString(const std::string & strInput,std::string &strEcho,tars::TarsCurrentPtr current) = 0;
        static void async_response_echoString(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &strEcho)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("strEcho", strEcho);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(strEcho, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 echoVector(const vector<tars::Int32> & vInput,vector<tars::Int32> &vEcho,tars::TarsCurrentPtr current) = 0;
        static void async_response_echoVector(tars::TarsCurrentPtr current, tars::Int32 _ret, const vector<tars::Int32> &vEcho)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("vEcho", vEcho);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(vEcho, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 test(tars::TarsCurrentPtr current) = 0;
        static void async_response_test(tars::TarsCurrentPtr current, tars::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __TarsTest__TypeDemo_all[]=
            {
                "echoBool",
                "echoByte",
                "echoInt",
                "echoLong",
                "echoMap",
                "echoMultiType",
                "echoShort",
                "echoString",
                "echoVector",
                "test"
            };

            pair<string*, string*> r = equal_range(__TarsTest__TypeDemo_all, __TarsTest__TypeDemo_all+10, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __TarsTest__TypeDemo_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Bool bInput = false;
                    tars::Bool bEcho = false;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("bInput", bInput);
                        tarsAttr.getByDefault("bEcho", bEcho, bEcho);
                    }
                    else
                    {
                        _is.read(bInput, 1, true);
                        _is.read(bEcho, 2, false);
                    }
                    tars::Int32 _ret = echoBool(bInput,bEcho, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("bEcho", bEcho);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(bEcho, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Char bInput;
                    tars::Char bEcho;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("bInput", bInput);
                        tarsAttr.getByDefault("bEcho", bEcho, bEcho);
                    }
                    else
                    {
                        _is.read(bInput, 1, true);
                        _is.read(bEcho, 2, false);
                    }
                    tars::Int32 _ret = echoByte(bInput,bEcho, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("bEcho", bEcho);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(bEcho, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 iInput;
                    tars::Int32 iEcho;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("iInput", iInput);
                        tarsAttr.getByDefault("iEcho", iEcho, iEcho);
                    }
                    else
                    {
                        _is.read(iInput, 1, true);
                        _is.read(iEcho, 2, false);
                    }
                    tars::Int32 _ret = echoInt(iInput,iEcho, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("iEcho", iEcho);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(iEcho, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int64 lInput;
                    tars::Int64 lEcho;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("lInput", lInput);
                        tarsAttr.getByDefault("lEcho", lEcho, lEcho);
                    }
                    else
                    {
                        _is.read(lInput, 1, true);
                        _is.read(lEcho, 2, false);
                    }
                    tars::Int32 _ret = echoLong(lInput,lEcho, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("lEcho", lEcho);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(lEcho, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    map<tars::Int32, std::string> mInput;
                    map<tars::Int32, std::string> mEcho;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("mInput", mInput);
                        tarsAttr.getByDefault("mEcho", mEcho, mEcho);
                    }
                    else
                    {
                        _is.read(mInput, 1, true);
                        _is.read(mEcho, 2, false);
                    }
                    tars::Int32 _ret = echoMap(mInput,mEcho, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("mEcho", mEcho);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(mEcho, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    vector<map<tars::Int32, std::string> > mtInput;
                    vector<map<tars::Int32, std::string> > mtEcho;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("mtInput", mtInput);
                        tarsAttr.getByDefault("mtEcho", mtEcho, mtEcho);
                    }
                    else
                    {
                        _is.read(mtInput, 1, true);
                        _is.read(mtEcho, 2, false);
                    }
                    tars::Int32 _ret = echoMultiType(mtInput,mtEcho, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("mtEcho", mtEcho);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(mtEcho, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Short sInput;
                    tars::Short sEcho;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("sInput", sInput);
                        tarsAttr.getByDefault("sEcho", sEcho, sEcho);
                    }
                    else
                    {
                        _is.read(sInput, 1, true);
                        _is.read(sEcho, 2, false);
                    }
                    tars::Int32 _ret = echoShort(sInput,sEcho, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("sEcho", sEcho);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(sEcho, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string strInput;
                    std::string strEcho;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("strInput", strInput);
                        tarsAttr.getByDefault("strEcho", strEcho, strEcho);
                    }
                    else
                    {
                        _is.read(strInput, 1, true);
                        _is.read(strEcho, 2, false);
                    }
                    tars::Int32 _ret = echoString(strInput,strEcho, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("strEcho", strEcho);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(strEcho, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    vector<tars::Int32> vInput;
                    vector<tars::Int32> vEcho;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("vInput", vInput);
                        tarsAttr.getByDefault("vEcho", vEcho, vEcho);
                    }
                    else
                    {
                        _is.read(vInput, 1, true);
                        _is.read(vEcho, 2, false);
                    }
                    tars::Int32 _ret = echoVector(vInput,vEcho, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("vEcho", vEcho);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(vEcho, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                    }
                    else
                    {
                    }
                    tars::Int32 _ret = test(_current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
